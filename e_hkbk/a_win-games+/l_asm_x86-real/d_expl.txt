
We can't understand the nature and purpose of the assembly language without discussing the following :
 |
 . abstraction (software taking care of things for you) vs. implementation (personally written instructions) 
 . legacy platforms - old tools and systems 
 . platform specifications (requirements) - the only things the system will work with 
 . compatibility modes , backwards compatibility
 . memory management , process memory layout
 . CPU control handover between the OS kernel and the subordinate process


========================================================================================
SOURCE CODE : 
========================================================================================

	org 100h
	ret


========================================================================================
16-BIT x86-BASED SYSTEMS and the REAL MODE : 
========================================================================================

This code , written in such fashion , is meant for systems that support the REAL MODE.


Real mode :
 |
 . the ability of a system to load and run programs with 16-BIT CODE AND DATA compiled
 |   for x86-based platforms
 |
 . NO MEMORY PROTECTION :
 |  . there's a chance that a process may access the memory allocated for another process
 |  . this is a security and stability problem 
 |
 . some 32- and 64- bit systems (backward compatible) may need specialized software
 |   to be able to run programs that require this mode 
 |
 . This is a so-called compatibility mode (there are others , such as the protected mode
 |   for 32-bit systems and the long mode for the 64-bit systems).
 |
 . no multitasking
 . direct access to hardware
 . 20-bit address space


========================================================================================
PRE- MAIN ENTRY DIRECTIVES : 
========================================================================================

	org 100h    	; This tells the CPU to place all of the main execution code
	    		; (here it's just 'ret') at this OFFSET - 0x100 from the start of
			; the memory layout of the process. Here's why : ... 


========================================================================================
PSP SEGMENT : 
========================================================================================

Memory segments : 
 |
 |
 @ + 100h : the OFFSET within the process layout where the code segment is to be situated 
 |
 @ +   0h : Program Segment Prefix (PSP)


Program Segment Prefix (PSP) :
 + command line arguments 
 + environment variables 
 . exists within every linked binary .COM executable file only manageable by DOS 


Command-line argument : 


Environment variables : 


Dynamic value :


========================================================================================
TRANSFERRING CONTROL OVER CPU BETWEEN PROCESSES : 
========================================================================================

 . the assembler follows the programmed directives (pre- main entry)
 |
 -> the kernel , being a process itself , gets the CPU to switch to executing our program 
 |   . (but we typically say that the kernel "gives our program the CONTROL OVER THE CPU)
 |   . this is called CONTEXT SWITCHING
 |
 -> we start execution of the MAIN CODE of the program (we get into the main SUBROUTINE) 
 -> (other stuff would be done , but in this particular program there isn't much to do
     but to exit)
     
	ret         	; -> and we move through the exit point of the main subroutine 

 -> CPU halts the execution and switches to executing the kernel 
     . we say that upon termination of this process we give control over the CPU back
       to the DOS kernel 

_
