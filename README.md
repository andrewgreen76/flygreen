# This is an experimental edutainment/tutorial repository - a work in progress. 

__________________________________________________________________________
The PURPOSE of this repo:
__________________________________________________________________________

To help individuals, with or without a technical background, to: 
- improve their productivity in general (combatting ADD, figuring out
  alternatives to unhealthy solutions, etc.) 
- (especially for beginners)
  - hone their programming skills,
  - internalize key programming and engineering concepts,
  - learn about different systems,
  - understand and build a perspective on modern computing through studying
    its history.
    
__________________________________________________________________________
The MANIFESTO is:
__________________________________________________________________________

> to run
  - to use for practical or artistic reasons
> to share
  - to show off
> to study
  - to learn
> to modify
  - to hack ethically and creatively
  
__________________________________________________________________________
TOPICS AND METHODS EXPLORED TO AN EXTENT OVER THE PAST 24-48 HOURS:
__________________________________________________________________________

- The near death of TurboC.
- Modern C :
  - basic : pointers, arrays, streaming, data manipulation
  - intermed : externs, unions, understanding orders of tokens at var init/def time. 
- Bash :
  - command substitution (with cat, grep, etc.)
  - understanding the role, the value, the pros, and the cons of :
    - local variables
    - environment variables
    - the tree-like nature of the shell and its processes
    - functions in Bash configs
  - forging and deploying custom bash funcs (which was painful but fun) 

__________________________________________________________________________
TECHNICAL OBSERVATIONS MADE OVER THE PAST 24-48 HOURS:

>>>	to trblsht/tech support dirs.

It is pretty upsetting that TurboC(++) is not cross-platform. That means
it can't be used at all for educational purposes. I understand that we have
something like Arduino for doing cool things like generating sound tones,
but there was a time when you could write just a few lines of code using
the dos.h library and get to not only playing sounds but also plotting pixels
on a PC. This user is not happy. To make matters worse, my impulsive
conversion of the Dell Inspiron, which had Windows as its native OS, to
Linux Ubuntu may have complicated things on the kernel level.

Perhaps I should do something about it. I'm not going to sacrifice my time
studying C, Rust, the Pop!_OS kernel, coreboot, and systemd for writing
an entire codebase for a safe, highly abstracted mirror of C, a fake,
that could tap into any hardware.

1) VM:
- 

2) DOSBox:
- But maybe there's something I could do inside DOSBox if at all. 

__________________________________________________________________________
CHOSEN PROFESSIONAL PROJECT:
__________________________________________________________________________

- (TBA)
v too bold ; let's do something simple ^ 
- maintaining [the Linux kernel] >>>or<<< systemd

__________________________________________________________________________
CHOSEN PERSONAL PROJECT:
__________________________________________________________________________

- Just A GAME FOR DOSBOX is fine.
|
|
- a virtual machine,
- an emulator,
- or a video game that poses as an operating system (a la Last Call BBS).
  - Can I use the Unity Engine for that?
  - research dedicated toolchains. 
- challenge: faithful resolution
- plan of attack:
  - fide: 320x200
  - now: 1920x1200, 6 times both ways.
  - consider fair, authentic scaling. 
- learn BIOS-kernel-API/DSP-distro ladder for that 
- An API / display server protocol for a 13h-like mode portable to any headless system.

