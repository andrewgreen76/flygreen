
In this project we finish implementing the kernel's protected mode
functionality in C because (we are told that) doing so in assembly
would be a pain. 


========================================================================================
MIXING C WITH ASSEMBLY - WHEN SHOULD WE CARE ABOUT ALIGNMENT ? 
========================================================================================

There are a couple of scenarios to consider where we combine C code with assembly code.

  (1) In most cases , where we simply create applications with the main
      entry point in C , we see a kind of flexibility when linking C-derived
      and assembly-derived object files - we do not have to bother with
      technical things like in-memory alignment.

  (2) However , when we structure the boot sector and the kernel code
      sector for a fledgling kernel with assembly files where the main
      entry point is established , we have to bother with alignment. 


========================================================================================
ALIGNMENT COMPLIANCE WHEN MIXING C WITH ASSEMBLY - IN THE CONTEXT OF KERNEL DEVELOPMENT
========================================================================================

"
If we go to linker.ld , you'll notice that our OUTPUT_FORMAT is binary.
  Now this is all fine , but when we start C with assembly , it can cause
  alignment issues. Now , C requires functions to be aligned in a certain
  way, and when we are writing assembly - in kernel.asm , for example -
  - and we are linking with object files created with the C compiler ,
  our assembly might not align correctly. 
"


PROBLEM: 
 . The C compiler aligns our generated object files in a certain way.
   This implies that the C CODE HAS TO BE COMPILED AND RUN FIRST and with
   everything else we have to work around that alignment limitation.

Solution ?
 . We could isolate 'boot' and 'kernel' resources by relegating them down
   into the .asm section of the linker script , so those would be linked
   and run later. However , ...

Problem :
 . 'boot' and 'kernel' are the first things we execute to run our fledgling
   OS (in QEMU or on a physical machine). Therefore , these things should
   precede any other code , even if it's C. 

Solution : 
 . We mix C and assembly. 

Problem : 
 . Our assembly code , when mixed with C code in memory , can violate
   the alignment. (A CC like GCC may not correctly align assembly binaries.) 


SOLUTION :
 . We make sure that our assembly code is ALIGNED TO 16 BYTES. This should
   allow us to blend our bootloader and kernel assembly code with the C section
   (.text section) in memory per the linker script. Then they can be linked
   and run first. 

_
