
========================================================================================
SOLUTION : 
========================================================================================

 . word -> [??? quick lookup ???] -> info
 |
 v
 . In order to come up with a solution that is GENERAL AND SIMPLE , we'll treat input numbers as strings.
 |
 v
 . string -> [quick lookup] -> info
 |
 v
 . string --()-> info
 |
 v
 . Of course , to find the info we need , we need to find its location. 
 |
 v
 . string --()-> specific location w/ info
 | 	  	 ^
 | 	  	 ^
 | 	  	 ^ How should info location be implemented ? 
 |  	         |
 |  	         . getting to the right node - O(n) -or- O(logn) 
 | 	      	 . getting to the right array cell - O(1) 
 |  	         => the ARRAY is chosen as the foundation for every hash table in modern databases
 |		 => thus we'll have an array of data structs 
 |	 	 . yes , storage space is sacrificed for speed 
 |		 |
 | 	         . the hash table's ARRAY HAS TO BE LARGE enough (for a dictionary , cust. database , etc.)
 |		 => we are probably wasting unused storage space , but in a way it's for the better (more on that later) 
 |		 | 
 |		 . we'll work with indices instead of addresses because they are an easy abstraction to work with 
 |
 |
 v
 . string   --()->   [num] {info} 
 |
 v
 . IDEA : convert the input string into something simple - a number - and convert that into an array index 
 |  . seems like the most intuitive thing to do
 |  . the same routine can be used for info addition , lookup , etc. 
 |
 v
 . string --()-> some (big) number --()-> [smaller num] {info} 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

This is great because this calls for a small number of simple operations to perform
an addition or a lookup no matter the case. 


     --(hashing)-> --(conversion-to-index)-> --(accessing)->


 => hash table operations like lookup can be done in constant time
 => again , this is better than traversing and comparing in linear time 

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

 . Conversion of the hash value (the intermediary number) to an array index is done with
   the modulo operator.
    |
    . Typical formula :


      	      hash_value % array_size = array_index for storing or lookup 

========================================================================================
APPLICATIONS :
========================================================================================

Private situation :
 | 
 . bank database 
    . (unique , private) key -> QUICK LOOKUP (of an entry in a database)
    | 
    . need a hash function (hashing algorithm) 
       . key -> hash code -> array index -> data set
       . key = unique number of any basis
    . HAS TO BE FAST 
       . O(1) , or 1:1
    . has to be difficult enough to maximize breaking time
       . otherwise , a hacker can generate a valid hash code soon enough 

.) encryption
    . or just data compression 
    . need a different kind of hash function
    . MD5 , SHA-1 , SHA-2 



Non-sensitive situation :
 | 
 . a word dictionary (disk -> RAM)
    . word -> QUICK LOOKUP (of an entry in a file)
    |
    . take a KEY (unique string or number of any basis)
    -> HASHING ALGORITHM : compute a (hopefully) unique hash code
    -> MODULO OPERATOR : compute the corresponding index 
    -> located bucket with the key (input) and the value ("output")
    . one and the same number of steps => O(1) 
 |
 . entry generation -> structure growth
    . key -> hash code -> array index -> data set

========================================================================
STIPULATIONS : 
========================================================================

 . bit-check ; 
    . content of something can be translated to a compressed string
    . avalanche effect (various algorithms) 
 . has to be fast enough to get through security    - to accommodate patience
 . has to be difficult enough to be slowly broken   - the malicious agent WILL have a good hash code  
 . collision 
    . but not too fast or a collision - coming up with the a hash code mapped to something else - will arise

========================================================================
Real-world examples :
========================================================================

 .

========================================================================
Simple , even phony example : 
========================================================================

 . 

========================================================================
WHAT IS IT LIKE , HOW DOES IT WORK :
========================================================================

 . "a data structure optimized for quick lookups"
   + an array (of "buckets")
      . yes, for a dictionary it would have to be a freaking huge array
        (hundreds of thousands , even millions of words)
      |
      |
      + collision => append the colliding node to the corresponding element in the array 
   + key-value pair(s) 
   + a hash function

              K       V          hash    i   <K,V>
           ----------------------------------------
       	    "253" , "John"   -> 95347 -> 0 | <K,V>
	     "42" , "Paul"   -> 38929 -> 1 | <K,V>
	    "368" , "George" -> 70353 -> 2 | <K,V>
	       .
	       .
	       .
=======================================================================
=======================================================================
=======================================================================
    . error / change detection

_
