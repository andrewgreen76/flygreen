
	different design philosophies and trade-offs



C++:	control, deep understanding, versatility. 
	+ memory management,
	- manual memory bugs (buffer overflows, null pointer dereferences, and memory leaks).

	+ winning the war of versatility (ecosystems and libraries)
    	+ concurrency models, such as threads, mutexes, and atomic operations.
	- manual synchronization and handling data races can be challenging and error-prone.

------------------------------------------------------------------------------------------------------

Sophisticated performance rivalry. 

    C++: C++ is known for its performance. It offers direct access to low-level hardware features and allows fine-grained control over memory layout and system resources. C++ compilers are highly optimized and have a long history of producing efficient machine code.
    Rust: Rust aims to provide comparable performance to C++. It offers zero-cost abstractions, allows low-level control, and provides high-level features without sacrificing efficiency. Rust's ownership and borrowing system enable safe abstractions with minimal runtime overhead.

------------------------------------------------------------------------------------------------------

Rust:	productivity / safety;
	concurrency.
	+ achieves concurrency on its own terms (locks/mutexes, semaphores, atomic operations)
	+ compile-time checks to prevent common memory bugs.
	+ ownership system, borrowing rules, and lifetimes :
	  + enable auto memgmt
	  + eliminate bugs like null pointer dereferences and data races.
	- slow growth of versatility 
    	+ processing multiple tasks. 

