
Condition variable :
. THE IDEA : complete obstruction of process/threads until a condition is satisfied
. CALLING THREAD : the main thread - the one that locks/unlocks and can have the critical section all to itself. 
. How it works :

//====================================================================================================================
    pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;	 
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 	 // The mutex and the condition variable are ALREADY LINKED.


    // ---------------------------- LOCK UP , CALLING THREAD IN ----------------------------------
    pthread_mutex_lock(&lock); 
    // -------------------------------------------------------------------------------------------


    // --------------- ACCESSING/MODIFYING DATA ... DOING WHAT MUST BE DONE ... ------------------


    // ---------------------- SOMETHING IS OFF AT THIS POINT OF PROCESS --------------------------
    // ---- SEND WAIT CALL : CALL.THREAD RELEASES THE MUTEX , LETS IN OTHER THREADS , SLEEPS -----
    // ------------- EITHER OTHER THREADS CHANGE THE CONDITION OR ALSO GO TO SLEEP  --------------
    |
    while (ready == 0)			 // the barring variable that threads share @ mutex release  
      pthread_cond_wait(&cond, &lock);	 // the WAIT CALL 
//====================================================================================================================
    pthread_mutex_lock(&lock);
    ready = 1;				// BARRING VARIABLE - declare all good 
    pthread_cond_signal(&cond);		// SIGNAL CALL - tell the calling thread to wake up 
    pthread_mutex_unlock(&lock);
//====================================================================================================================    
    // (1) SEND cond SIGNAL , (2) HAVE barring variable GIVE OK. 
    // Calling thread reacqs mutex. Then , ... 


    pthread_mutex_unlock(&lock);    // calling thread releases mutex : reacq again , block other threads here 
    pthread_mutex_lock(&lock);      // reacqs mutex to block other threads here
        // may recheck the barring and condition variables 
	// may continue working on shared data 
    pthread_mutex_unlock(&lock);    // calling thread releases mutex , just in time for end of crit.section.  
//====================================================================================================================






More than one thread can wait on the condition.
. A single sleeping thread can be woken up to proceed by calling ... 

     pthread_cond_signal(&cond);

. All present sleeping threads can be woken up by calling ...

     pthread_cond_broadcast(&cond); 



======================================================================================================================
======================================================================================================================
======================================================================================================================
    // --------------- CALLING THREAD DOING WHAT MUST BE DONE ... WRAPPING UP ... ------------------
======================================================================================================================
======================================================================================================================
======================================================================================================================
More thoughts :
. Mutex and condition-on-mutex protect code and data in a critical section that could be otherwise be shared between threads. 
. the mutex can be ...
  . a regular mutex
  . a regular timedlock
  . a trylock 

======================================================================================================================
======================================================================================================================
======================================================================================================================

"
Condition variables are synchronization primitives used in multithreaded programming to allow threads to efficiently wait for a specific condition to be met before proceeding. They are often used in conjunction with mutexes to coordinate the activities of multiple threads.

Here is a high-level overview of how condition variables work between two threads:

1. **Initialization:**
   - A condition variable is associated with a mutex to form a condition variable-mutex pair. This mutex is used to protect the shared data that the condition variable is associated with.

   ```c
   pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
   pthread_cond_t condition_variable = PTHREAD_COND_INITIALIZER;
   ```

2. **Mutex Lock and Shared Data:**
   - The threads involved should lock the shared data using the associated mutex before checking or modifying the shared data.

   ```c
   pthread_mutex_lock(&mutex);
   // Access or modify shared data
   ```

3. **Checking the Condition:**
   - If a thread finds that the condition it is interested in is not met, it can voluntarily release the mutex and enter a waiting state using `pthread_cond_wait()`. This releases the mutex, allowing other threads to access the shared data.

   ```c
   while (!condition) {
       pthread_cond_wait(&condition_variable, &mutex);
   }
   ```

   The `pthread_cond_wait()` function atomically releases the mutex and puts the calling thread to sleep until the condition variable is signaled by another thread.

4. **Signaling the Condition:**
   - Another thread that modifies the shared data and believes that the condition has been met can signal the condition variable using `pthread_cond_signal()` or `pthread_cond_broadcast()`.

   ```c
   // Modify shared data
   condition = true;
   pthread_cond_signal(&condition_variable); // or pthread_cond_broadcast(&condition_variable);
   ```

   The `pthread_cond_signal()` function wakes up at least one thread waiting on the condition variable. If multiple threads are waiting, `pthread_cond_broadcast()` wakes up all waiting threads.

5. **Mutex Unlock:**
   - After signaling the condition, the signaling thread should release the mutex.

   ```c
   pthread_mutex_unlock(&mutex);
   ```

6. **Wakeup and Recheck:**
   - The thread that was waiting on the condition variable wakes up and reacquires the mutex. It then rechecks the condition to ensure that it is still true.

   ```c
   pthread_mutex_lock(&mutex);
   // Recheck the condition
   // Continue processing or modify shared data
   pthread_mutex_unlock(&mutex);
   ```

This sequence of operations ensures that threads are synchronized around a shared condition, and they efficiently wait until the condition becomes true before proceeding.

It's important to note that using condition variables typically involves both a condition check and a loop to recheck the condition after waking up. This is because of the potential for spurious wakeups, where a thread wakes up even though the condition might not have changed. The loop allows the thread to recheck the condition and, if necessary, go back to waiting.
"
_
